<!DOCTYPE html>
<html lang="en">
    <head>
	<meta name="generator" content="Hugo 0.91.2" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>📚 | Dev Blog</title><meta name="Description" content=""><meta property="og:title" content="📚 | Dev Blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jaeyeonme.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="📚 | Dev Blog"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="📚 | Dev Blog">
<meta name="apple-mobile-web-app-title" content="📚 | Dev Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jaeyeonme.github.io/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="📚 | Dev Blog">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="📚 | Dev Blog"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/jaeyeonme.github.io\/","inLanguage": "en","author": {
                "@type": "Person",
                "name": "Jaeyeon"
            },"name": "📚 | Dev Blog"
    }
    </script></head>
    <body header-desktop="auto" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="📚 | Dev Blog">📚 | Dev Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="📚 | Dev Blog">📚 | Dev Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page home" posts><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="Posts"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/profile.png"
        data-srcset="/images/profile.png, /images/profile.png 1.5x, /images/profile.png 2x"
        data-sizes="auto"
        alt="/images/profile.png"
        title="/images/profile.png" /></a></div><h2 class="home-subtitle"><div id="id-1" class="typeit"></div></h2><div class="links"><a href="https://github.com/jaeyeonme" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href="mailto:cjyeon1022@gmail.com" title="Email" rel=" me"><i class="far fa-envelope fa-fw"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-mapping-various-associations/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-mapping-various-associations/">다양한 연관관계 매핑</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 연관관계 매핑시 고려사항 3가지   다중성  다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany → 다대다는 실무에서 사용하면 안된다. 단방향, 양방향  테이블  외래 키 하나로 양쪽 조인 가능 방향이라는 개념이 없음 양쪽이 서로 참조하면 양방향       연관관계의 주인  테이블은 외래 키 하나로 두 데이블의 연관관계를 찾음 객체 야방향 관계는 A → B, B → A 처럼 참조가 2군데 연관관계의 주인: 외래 키를 관리하는 참조 주인의 반대편 : 외래 키에 영향을 주지않고 단순 조회(참조)만 가능    2. 다대일 [N:1]  다대일(N:1) 단방향   ERD
다대일(N:1)단방향
 가장 많이 사용하는 연관관계 다대일의 반대는 일대다    다대일 양방향   ERD
 외래 키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발 연관관계가 주인이 아닌 쪽은 단순 조회만 가능하기에 필드만 추가해주면 된다.  @OneToMany private List&lt;Member&gt; members = new ArrayList&lt;&gt;();   3. 일대다 [1:N]  일(One)이 연관관계의 주인이다. → 권장하는 방법은 아니다. 실무에서도 거의 사용되지 않음
  ERD
 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있다. 객체와 테이블의 차이 떄문에 반대편 테이블의 외래키를 관리하는 특이한 구조    권장하지 않는 이유   테이블에서는 항상 다(N) 쪽에 외래키가 있기 때문에 패러다임충돌이 있다.
  @JoinColumn 을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다. (중간에 테이블을 하나 추가함)
  실무에서는 테이블이 수십개 이상 운영이 되는데, 관리 및 트레이싱이 어렵다.
→ Ex) 일대다(1:N)에서 저장(save)이 될 때 양쪽 객체를 저장한 뒤 update query를 통해 외래키 설정(3번이나 수행)
   결론: 기본은 다대일(N:1)로 구현하다 필오에 의해 양방향 다대일(N:1) 관계를 수립하도록 하자.
 일대다(1:N)양방향   ERD
  이런 매핑은 공식적으로는 존재하지 않는다.
  @JoinColumn(insertable=false, updatable=false)
/* 팀(Team) */ public class Team{ ... @OneToMany @JoinColumn(name=&#34;TEAM_ID&#34;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); ... } /* 멤버(Member) */ public class Member{ ... @ManyToOne @JoinColumn(name=&#34;TEAM_ID&#34;, insertable=false, updatable=false) private Team team; ... } → Member ENtity의 team field가 읽기전용 field가 됐다.
     읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용하자.  4. 일대일(1:1)   주 테이블이나 대상 테이블 중에 외래 키 선택 가능 외래키에 데이터베이스 유니크 제약조건 추가 다대일 연관관계와 동일하게 외래키가 있는곳이 연관관계의 주인 연관관계의 주인이 아닌 곳에 mappedBy를 넣어준다. 정리  주 테이블에 외래 키  주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매핑 정리 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점 : 값이 없으면 외래 키에 null 허용   대상 테이블의 외래 키  대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 단점 : 주 테이블에는 외래 키가 없기 때문에 대상 테이블이 있는지 없는지 알 수 없기 때문에 즉시로딩이 무조건 된다.      5. 다대다 [N:M]   실무에서는 거으 ㅣ사용하지도 않고 추천하지도 않는 연관관계 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능 @ManyToMany 사용 @JoinTable로 연결 테이블 지정  다대다 매핑의 한계  편리해 보이지만 실무에서 사용안함 연겵 테이블이 단순히 연결만 하고 끝나지 않음 주문시간, 수량 같은 데이터가 들어올 수 있음.</div><div class="post-footer">
        <a href="/posts/jpa-mapping-various-associations/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-mapping-basics/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-mapping-basics/">연관관계 매핑 기초</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 연관관계의 필요성  : 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.
2. 객체를 테이블에 맞춰 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다. 2-1. 객체를 테이블에 맞추어 모델링(연관관계가 없는 객체)   객체를 테이블에 맞추어 모델링 (참조 대신에 외래 키를 그대로 사용)
/* 회원(Member) 엔티티*/ @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = &#34;USERNAME&#34;) private String name; @Column(name = &#34;TEAM_ID&#34;) private Long teamId; } /* 팀(Team) 엔티티 */ @Entity public class Team{ @Id @GeneratedValue private Long id; private String name; }  객체를 위와 같이 테이블에 맞춰 모델링을 할 경우 생기는 문제는 무엇일까?      객체를 테이블에 맞춰 모델링 했을 경우 DB에 저장&amp;조회하는 로직
/* 팀과 멤버를 저장하는 로직 */ Team team = new Team(); team.setName(&#34;teamA&#34;); em.persist(team); Member member = new Member(); member.setName(&#34;mamber1&#34;); member.setTeamId(team.getId()); em.persist(member);  외래키 식별자를 직접다루고 있는데, 이럴 경우 문제는? → 조회할 때 역시 해당 외래키를 가지고 조인 쿼리를 직접 짜야 한다. Q. member1 이 소속된 팀 정보를 조회하려면 어떻게 해야하는가?  Member findMember = em.find(Member.class, member.getId()); Long findTeamId = findMember.getTeamId(); Team findTeam = em.find(Team.class, findTeamId);  매번 member를 우선 조회한 뒤 외래키를 뽑아 그것으로 팀의 정보를 조회해야 한다. → 협력관계를 만들 수 없다.    Hibernate: create table Member ( MEMBER_ID bigint not null, TEAM_ID bigint, USERNAME varchar(255), primary key (MEMBER_ID) ) Hibernate: create table Team ( TEAM_ID bigint not null, name varchar(255), primary key (TEAM_ID) )  결론: 외래키를 직접 관리하는 테이블에 맞춘 객체 모델링은 객체간의 협력관계를 만들 수 없고, 객체가 참조를 통해 연관객체를 찾는 다는 사상을 적용할 수 없다. 이 말은 객체지향 프로그래밍의 패러다임을 정면으로 반박하는 것.
  객체 지향 모델링 (객체 연관관계 사용)
   객체 지향적으로 엔티티 설계(객체 연관관계 사용)
/* 회원(Member) 엔티티*/ @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = &#34;USERNAME&#34;) private String name; @ManyToOne @JoinColumn(name = &#34;team_id&#34;) private Team team; ... getter, setter }  @ManyToOne @JoinColumn 을 통해 멤버(Member)에서 팀(Team)을 참조하도록 헀다.    Team team = new Team(); team.setName(&#34;teamA&#34;); em.persist(team); Member member = new Member(); member.setName(&#34;mamber1&#34;); member.setTeam(team); em.persist(member); em.flush(); em.clear(); Member findMember = em.find(Member.class, member.getId()); Team findTeam = member.getTeam(); 
3. 양방향 연관관계와 연관관계 주인1 - 기본    단방향에서 양방향이 된다는 것의 의미는 양측에서 서로 참조할 수 있다는 것이다. 기존 단방향에서는 Member 에서 getTeam()을 통해 Team 엔티티를 참조할 수 있지만 Team 에서는 Member 를 참조할 수 없었다. 하지만 테이블 연관관계에서는 외래키를 가지고 양측에서 서로를 참조할 수 있다.
  Team 객체에 members라는 List를 추가해서 양방향 연관관계를 만들어준다.
@Entity public class Team{ ... @OneToMany(mappedBy = &#34;team&#34;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); ... }     추가한 members 를 확인하는 코드를 작성해보자.
Member findMember = em.find(Member.class, member.getId()); List&lt;Member&gt; members = findMember.getTeam().getMembers(); for (Member member1 : members) { System.out.println(&#34;member1.getName() = &#34; + member1.getName()); // member1.getName() = mamber1 }  이제 반대방향으로도 객체 그래프 탐색이 가능해졌다.    연관관계의 주인과 mappedBy  mappedBy = 연관관계의 개념에 대해 이해를 어렵게 만드는 주범! 객체와 테이블간 연관관계를 맺는 차이를 이해해야 한다.  객체와 테이블이 관계를 맺는 차이란?  객체 연관관계 = 2개  회원 → 팀 연관관계 1개(단방향) 팀 → 회원 연관관계 1개(단방향)   테이블 연관관계 = 1개  회원 ←→ 팀의 연관관계 1개(양방향)    결국 양방향 관계란  객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.</div><div class="post-footer">
        <a href="/posts/jpa-mapping-basics/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-entity-mapping/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-entity-mapping/">엔티티매핑</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">엔티티 매핑 소개   객체와 테이블 매핑 : @Entity , @Table 필드와 컬럼 매핑 : @Column 기본 키 매핑 : @Id 연관관계 매핑 : @ManyToOne , @JoinColumn  JPA로 데이터베이스 스키마를 자동 생성하는 방법 JPA로 어플리케이션 로딩 시점에 테이블을 생성할 수 있다. 일일이 스키마를 수정하기 힘든 개발 환경에서 사용하면 좋다. 운영에서 쓰려면 절대 그대로 사용해서 안 되고 다듬어야 한다.
엔티티 매핑을 해놓으면, JPA가 어플리케이션 실행 시점에 DDL을 자동 생성하여 수행한다. 객체 중심으로 개발해 놓기만 하면 되니 테이블을 건드릴 필요 없다. 게다가 데이터베이스 방언(dialect)를 활용해 DB에 알맞는 DDL을 만든다.
스프링 부트에선 spring.jpa.hibernate.ddl-auto 속성으로 스키마 생성 전략을 설정할 수 있다.
  create : 기존 테이블 삭제 후 다시 생성 (DROP -&gt; CREATE)
  create-drop : create + 종료 시점 drop (DROP -&gt; CREATE -&gt; DROP)
  update : 추가된 사항만 반영, 이미 반영된 것을 지우는 작업은 불가능! (특히 운영DB에서 사용하면 안 됨)
  validate : 엔티티와 테이블이 알맞게 매핑되었는지 검증
  none : 사용하지 않음
  로컬 서버에서 자유롭게 사용하고, 여러 명의 개발자가 사용하는 서버에선 사용하지 않는 게 좋다.
create / create-drop은 기존 테이블을 드랍하기 때문에 기존 데이터를 날려버리고, update는 alter문을 실행하면서 테이블 lock을 걸기 때문에 조심해야 한다.
실무에서는 validate 를 사용
1. 객체와 테이블 매핑 @Entity   @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의  기본 생성자 필수 (파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용X    @Entity 속성 정리   속성 : name  JPA에서 사용할 엔티티 이름을 지정한다. 기본값 : 클래스 이름을 그대로 사용 (예: Member) 같은 클래스 이름이 없으면 가급적 기본값을 사용한다.    주의할 점
 기본 생성자 필수 (public or protected) final 클래스 / inner 클래스 / enum / interface 에는 사용 불가능 DB 컬럼과 매핑될 필드에 final 사용 불가능  @Table   @Table은 엔티티와 매핑할 테이블 지정     속성 기능 기본값     name 매핑할 테이블 이름 엔티티 이름을 사용   catalog 데이터베이스 catalog 매핑    schema 데이터베이스 schema 매핑    uniqueConstrints (DDL) DDL 생성 시에 유니크 제약 조건 생성     2. 데이터베이스 스키마 자동 생성  데이터베이스 스키마 자동 생성  DDL을 어플리케이션 실행 시점에 자동 생성 테이블 중심 → 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성된 DDL은 개발 장비에서만 사용 생성된 DDL은 운영서버에서는 사용되지 않거나 적절히 다듬은 후 사용  데이터베이스 스키마 자동 생성 - 속성  hibernate.hbm2ddl.auto  create : 기존 테이블 삭제 후 다시 생성 (DROP + CREATE) create-drop : create와 같으나 종료시점에 테이블 DROP update : 변경분만 반영 (운영DB에는 사용하면 안됨) validate : 엔티티와 테이블이 정상 매핑되었는지만 확인 none : 사용하지 않음    DDL 생성 기능  제약조건 추가 : 회원 이름 필수 , 10자 초과 X  @Column(nullable = false, length = 10)   유니크 제약조건 추가  @Table(uniqueConstraints = {@UniqueCOnstraint(name = &quot;NAME_AGE_UNIQUE&quot;, columnNames = {&quot;NAME&quot;, &quot;AGE&quot;})})   DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.</div><div class="post-footer">
        <a href="/posts/jpa-entity-mapping/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-persistence-management-works/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-persistence-management-works/">영속성관리 - 내부 동작 방식</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 영속성 컨텍스트  웹 어플리케이션이 구동하는 시점에 EntityManagerFactory 를 생성하여 가지고 있으며, 사용자의 요청이 있을 때 EntityManager를 생성하여 커넥션 풀(Connection Pool)을 사용해서 DB를 핸들링 하게 된다.  영속성 컨텍스트란?   엔티티를 영구 저장하는 환경
  EntityManager.persist(entity);
→ DB에 저장한다기 보다는 영속성 컨텍스트를 통해 엔티티를 영속화 한다는 의미
 영속성 컨텍스트에 엔티티를 저장한다는 말    영속성 컨텍스트는 논리적인 개념
  눈에 보이지 않는다.
  엔티티 매니저를 통해서 영속성 컨텍스트에 접근
 J2SE 환경    엔티티의 생명 주기  비영속(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속(managed): 영속성 컨텍스트에 관리되는 상태 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed): 삭제된 상태  비영속 : JPA에 관계없이 객체 생성만 된 상태
// 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); 
영속 // 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); // 객체를 저장한 상태(영속) em.persist(member); 
준영속, 삭제 // 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태 em.detach(member); // 객체를 삭제한 상태(삭제) em.remove(member);  준영속: 영속성 컨텍스트에서 삭제하는 것 삭제는 실제로 DB에서 해당 ROW를 삭제하는 것  2. 영속성 컨텍스트의 이점 1. 1차 캐시 Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); //1차 캐시에 저장됨 em.persist(member); //1차 캐시에서 조회 Member findMember = em.find(Member.class, &#34;member1&#34;);  조회 시 영속 컨텍스트안에서 1차 캐시를 조회 후 해당 엔티티가 있을 경우 캐시를 조회 해 온다. 조회 시 영속 컨텍스트 안에서 1차 캐시를 조회 후 해당 엔티티가 없을 경우 데이터베이스에서 조회해 온다. 데이터베이스 트랜잭션 내부에서 만들고 종료되기 때문에 하나의 비즈니스 로직이 종료될 경우 1차캐시는 다 사라지기 때문에 큰 도움이 되지 않는다. (비즈니스 로직이 복잡해 질 수록 효과는 커진다.)  2. 동일성(identity) 보장 Member findMember = em.find(Member.class, 100L); Member findMember2 = em.find(Member.class, 100L); System.out.println(findMember == findMember2); // true : 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
 참고: 트랜잭션의 격리수준이 궁금하면 트랜잭션이 보장해야 하는 ACID를 기억하자.
 3. 엔티티 등록 - 트랜잭션을 지원하는 쓰지지연 Member member = new Member(150L, &#34;A&#34;); Member member2 = new Member(160L, &#34;B&#34;); em.persist(member); em.persist(member2); // 엔티티 등록은 아직 수행되지 않는다. (쓰지 지연)  System.out.println(&#34;=========&#34;); tx.commit(); // 에티티 등록은 이 떄 동시에 수행된다. 
memberA와 memberrB는 둘 다 쓰기지연 SQL저장소에 저장되어있고 실제 DB에 적용은 안된 상태
commit() 시점에 쓰기지연 SQL에 저장된 쿼리들을 다 실행시켜서 DB에 적용한다.
쓰기 지연을 사용하는 이유
-&gt; 버퍼링 기능이 제공
&lt;property name=&#34;hibernate.jdbc.batch_size&#34; value=&#34;10&#34;/&gt; -&gt; 10개씩 쌓일때마다 적용하게 하는 기능
-&gt; 쿼리를 여러번 날리지 않고 최적화가 가능하다.
4. 엔티티 수정 - 변경감지(Dirty Checking) transaction.begin(); //엔티티 조회 Member findMember = em.find(Member.class, &#34;memberA&#34;); //영속 엔티티 데이터 수정 findMember.setUsername(&#34;hi&#34;); findMember.setAge(10); transaction.commit(); → 1차 캐시안에는 @Id, Entity , 스냅샷 이 있다. 여기서 스냅샷 은 최초로 영속성 컨텍스트(1차캐시)에 들어오는순간 스냅샷을 찍어서 저장해둔다.
→ JPA는 트랜잭션이 커밋(commit)되는 순간 엔티티와 스냅샷을 모두 비교한다.
→ 변경된 것이 있을 경우 쓰기지연 SQL 저장소 에 업데이트 쿼리를 저장하고 수행하게 된다.
5. 엔티티 삭제 //삭제 대상 엔티티 조회 Member member = em.find(Member.class, &#34;memberA&#34;); em.remove(member);//엔티티 삭제 
3. 플러시(flush) : 영속성 컨텍스트의 변경을 데이터베이스에 반영(sync)
  플러시 발생
 변경 감지 수정된 엔티티 쓰기지연 SQL 저장소에 등록 쓰기 지연 SQL저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)    영속성 컨텍스트를 플러시 하는 방법</div><div class="post-footer">
        <a href="/posts/jpa-persistence-management-works/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.91.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Jaeyeon</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"data":{"id-1":"Life of record"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"typeit":{"cursorChar":"|","cursorSpeed":500,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
