<!DOCTYPE html>
<html lang="en">
    <head>
	<meta name="generator" content="Hugo 0.91.2" />
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>📚 | Dev Blog</title><meta name="Description" content=""><meta property="og:title" content="📚 | Dev Blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jaeyeonme.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="📚 | Dev Blog"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="📚 | Dev Blog">
<meta name="apple-mobile-web-app-title" content="📚 | Dev Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jaeyeonme.github.io/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="📚 | Dev Blog">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="📚 | Dev Blog"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/jaeyeonme.github.io\/","inLanguage": "en","author": {
                "@type": "Person",
                "name": "Jaeyeon"
            },"name": "📚 | Dev Blog"
    }
    </script></head>
    <body header-desktop="auto" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="📚 | Dev Blog">📚 | Dev Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="📚 | Dev Blog">📚 | Dev Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page home" posts><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="Posts"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/profile.png"
        data-srcset="/images/profile.png, /images/profile.png 1.5x, /images/profile.png 2x"
        data-sizes="auto"
        alt="/images/profile.png"
        title="/images/profile.png" /></a></div><h2 class="home-subtitle"><div id="id-1" class="typeit"></div></h2><div class="links"><a href="https://github.com/jaeyeonme" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href="mailto:cjyeon1022@gmail.com" title="Email" rel=" me"><i class="far fa-envelope fa-fw"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-object-query-language1/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-object-query-language1/">객체지향 쿼리 언어 - 기본 문법</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-30">2021-12-30</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 소개  JPA는 다양한 쿼리 방법을 지원
 JPQL JPA Criteria QueryDSL Native SQL JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용  JPQL 소개
 가장 단순한 조회 방법  EntityManager.find() 객체 그래프 탐색 (a.getB().getC())   나이가 18살 이상인 회원을 모두 검색하고 싶다면?  JPQL - 필요성
 JPA를 사용하면 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검 색 조건이 포함된 SQL이 필요  JPQL - 특징
  JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리를 제공
String sql = &#34;select m from Member.class as m where m.username like &#39;%until%&#39;&#34;; 일반 SQL과 비슷하지만 엔티티를 대상으로 한다는 점이 다르다.
 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다. 동적 쿼리 생성이 쉽지 않다.    Criteria - 소개
 문자가 아닌 자바코드로 JPQL을 작성할 수 있음  //Criteria 사용 준비 CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class); //루트 클래스 (조회를 시작할 클래스) Root&lt;Member&gt; m = query.from(Member.class); //쿼리 생성 CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(&#34;username&#34;), “kim”)); List&lt;Member&gt; resultList = em.createQuery(cq).getResultList()  JPQL 빌더 역할 JPA 공식 기능  ❌실무에선 거의 사용되지 않는다.
 쿼리를 동적으로 생성할 수는 있지만 구현이 너무 복잡하고 실용성이 없다. 문자가 아닌 자바코드로 JPQL을 작성할 수 있음 JPQL 빌더 역할 JPA 공식 기능 단점 : 너무 복잡하고 실용성이 없다. Criteria 대신에 QueryDSL 사용 권장  QueryDSL 소개
오픈소스 라이브러리
// JPQL // SELECT m from Member m WHERE m.age &gt; 18 JPAFactoryQuery query = new JPAQueryFactory(em); QMember m = QMember.member; List&lt;Member&gt; list = query.selectFrom(m) .where(m.age.gt(18)) .orderBy(m.name.desc()) .fetch();   문자가 아닌 자바코드로 JPQL을 작성할 수 있음
  JPQL 빌더 역할
  컴파일 시점에 문법 오류를 찾을 수 있음
  ... List&lt;Member&gt; list = query.selectFrom(m) .wheree(m.age.gt(18)) //컴파일 시점에서 오류 검출 가능  .orderBy(m.name.desc()) .fetch()  동적쿼리 작성 편리함 단순하고 쉽다. 실무 사용 권장  네이티브 SQL 소개
  JPA가 제공하는 SQL을 직접 사용하는 기능
  JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능
 ex: 오라클 CONNECT BY, 특정 DB만 사용한는 SQL 힌트  String sql =&#34;SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = ‘kim’&#34;; List&lt;Member&gt; resultList = em.createNativeQuery(sql, Member.class) .getResultList();   JDBC 직접 사용, SpringJdbcTemplate 등
  PA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등 함꼐 사용가능
  단, 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요
 ex: JPA를 우회해서 SQL을 실행하기 직전 영속성 컨텍스트를 수동 플러시 해줘야 한다.  Member member = new Member(); member.setUsername(&#34;catsbi&#34;); conn.createQuery(&#34;select * from Member where username = &#39;catsbi&#39;&#34;); //결과 없음 member는 Jdbc가 쿼리를 수행하는시점에서 영속성 컨텍스트에만 있고 db에 아직 저장되지 않았기 때문에 조회결과가 없다 그러므로 쿼리 수행 전 수동으로 플러시를 해줘야 한다.
  2. 기본 문법과 쿼리 API  JPQL 소개
 JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.  EX: 조회 기능을 만들 때 특정 DB에 의존하는 SQL을 따로 안만들어도 된다.   JPQL은 결국 SQL로 변환된다.  객체/DB 모델</div><div class="post-footer">
        <a href="/posts/jpa-object-query-language1/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-value-type/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-value-type/">값 타입</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 기본값 타입  엔티티 타입
  @Entity로 정의하는 객체
  데이터가 변해도 식별자로 지속해서 추적 가능
⇒ 엔티티 내부의 모든 값들을 바꿔도 식별자만 유지되면 추적이 가능하다는 의미
  Ex: 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
  값 타입
 int, integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적 불가 Ex: 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체  값 타입 분류
 기본값 타입  자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String   임베디드 타입(enbedded type, 복합 값 타입)  Ex: 우편번호, 좌표같은 복합 값을 Position클래스로 만들어 쓰려고 하는 것을 임베디드 타입   컬렉션 값 타입(collection value type)  Java collection(Array, Map, Set)에 값을 넣을수 있는 것을 컬렉션 값 타입이라 한다.    값 타입 : 기본값 타입
 Ex: String name, int age 생명주기를 엔티티에 의존  회원을 삭제하면 이름, 나이 필드도 함께 삭제   값 타입은 공유하면 안된다.  Side Effect → 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안된다.     참고: 자바의 기본 타입은 절대 공유가 되지 않는다.  int, double 같은 기본 타입(primitive type)은 절대 공유되지 않는다. 기본 타입은 항상 값을 복사함 Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경할 수 없다.    2. 임베디드 타입  개요
 새로운 값 타입을 직접 정의할 수 있다. JPA는 임베디드 타입(embedded type)이라 한다. 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입  임베디드 타입 사용법
 @Embeddable : 값 타입을 정의하는 곳에 표시 @Embedded : 값 타입을 사용하는 곳에 표시 기본 생성자 필수   Example  예제를 통해 알아보는게 이해하기 쉽다.  회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다.
  city, street, zipcode는 주소로 합칠 수 있을 것 같다.
  근무 시작일, 근무 종료일은 근무시간으로 합칠 수 있을 것 같다.
  회원 엔티티의 몇몇 값을 주소, 근무시간으로 합치면 어떻게 될까.
코드를 통해 좀 더 자세히 알아보자.
@Embeddable //값 타입이 정의되는 곳에 @Embeddable 사용 public class Period { private LocalDateTime startDate; private LocalDateTime endDate; public Period() { } } @Embeddable //값 타입이 정의되는 곳에 @Embeddable 사용 public class Address { private String city; private String street; private String zipcode; public Address() { } } @Entity public class Member { @Id @GeneratedValue @Column(name = &#34;MEMBER_ID&#34;) private Long id; @Column(name = &#34;USERNAME&#34;) private String name; /* //임베디드 타입을 사용하지 않으면 주석 내의 기존 형태로 값 타입으로 선언해줘야 한다. //Period private LocalDateTime startDate; private LocalDateTime endDate; //Address private String city; private String street; private String zipcode; */ @Embedded //값 타입이 사용되는 곳에 @Embedded 사용  private Period workPeriod; @Embedded //값 타입이 사용되는 곳에 @Embedded 사용  private Address homeAddress; } 
임베디드 타입의 장점
 재사용  Period나 Address는 다른 객체에서도 사용할 수 있어 재사용성을 높힌다.   높은 응집도 Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있음  private boolean isWork(){ ... }  임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존한다.</div><div class="post-footer">
        <a href="/posts/jpa-value-type/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-proxy-and-management/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-proxy-and-management/">프록시와 연관관계 관리</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 프록시   프록시란?
 테이블을 조회해서 객체를 가져올 때 연관관계 객체는 안가져 오고 싶으면 어떻게 해야 할까?
  em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
Member member = em.getReference(Member.class, 1L); System.out.println(&#34;member = &#34; + member.getClass()); // HibernateProxy 객체 getReference() 메서드를 사용하면 진짜 객체가 아닌 하이버네이트 내부 로직으로 프록시 엔티티 객체 반환
내부 구조는 틀은 같지만 내용이 비어있다.
프록시 객체를 반환한다." 프록시 객체를 반환한다.    특징
  실제 클래스를상속받아서 만들어짐
  실제 클래스와 겉 모양이 같다.
  사용하는 입장에서는 진짜 객체인지 구분 필요가 없다. (이론적으로)
  프록시 객체는 실제 객체의 참조(target)를 보관한다.
  프록시 객체를 호출(getName())하면 프록시 객체는 실제 객체의 메소드 호출
  프록시는 처음 사용할 때 한 번만 초기화
  프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해 실제 엔티티에 접근 가능
  프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함( == 비교 실패, 대신 instance of 사용)
m1.getClass() == m2.getClass() //false m1 instanceof Member m2 instanceof Member     영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
Member m1 = em.find(Member.class, member1.getId()); System.out.println(&#34;m1 = &#34;+ m1.getClass());//Member  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(&#34;reference = &#34; reference.getClass()); //Member  m1 == reference //true 이미 Member를 1차 캐시에도 올라와 있는데, 프록시를 반환할 필요가 없다.
    반대로 getReference()로 프록시객체를 가지고 있으면 실제로 find()를 했을때도 프록시 객체를 반환함
  영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
Member refMember = em.getReference(Member.class, member.getId()); System.out.println(&#34;refMember = &#34;+ refMember.getClass());//Proxy  em.detach(refMember); //em.clear  refMember.getUsername(); //org.hibernate.LazyInitializationException   프록시 객체의 초기화
Member member = em.getRefernce(Member.class, &#34;id1&#34;);//(1) member.getName();//(2) 코드 1라인에서 getReference()를 호출하면 프록시객체를 가져온 다음, getName()을 호출하면
JPA가 영속성 컨텍스트에 초기화 요청을 한다.
영속성 컨텍스트에서는 실제 DB를 조회해서 가져온 다음 실제 Entity에 값을 넣어 생성한 다음 프록시 객체는
실제 엔티티를 연결해서 실제 엔티티를 반환한다.
그 이후에는 이미 초기화되어있는 프록시객체 여기에 해당 엔티티를 반환한다.
프록시 확인
 프록시 인스턴스의 초기화 여부 확인 : PersistenceUnitUtil.isLoaded(Object entity) → entityManagerFactory.getPersistenceUnitUtil().isLoaded(object) 프록시 클래스 확인 방법 : entity.getClass().getname() 출력(..javasist.. or HibernateProxy&hellip;) 프록시 강제 초기화 : org.hibernate.Hibernate.initialize(entity); 참고: JPA 표준은 강제 초기화 없음 강제호출 : method.getName();  2. 즉시로딩과 지연로딩  지연 로딩 Member를 조회할 때 Team(연관관계)도 함께 조회해야 할까? : 단순히 member 정보만사용하는 비즈니스 로직
지연 로딩 LAZY을 사용해서 프록시로 조회
fetch = FetchType.LAZY
/*Member*/ @Entity public class Member { ... @ManyToOne(fetch = FetchType.LAZY) //지연로딩 사용  @JoinColumn(name=&#34;TEAM_ID&#34;) private Team team; ... } ... Member m = em.find(Member.class, member1.getId()); // Member 객체 반환 System.out.println(&#34;m = &#34;+ m.getTeam().getClass()); // Team$HibernateProxy객체 반환 m.getTeam().getName() // team을 실제로 사용하는 시점에서 db조회 엔티티 반환 ... 연관관계에 있는 다른 엔티티를 사용하는 빈도수가 낮을 경우 지연로딩을 사용해 불필요한 엔티티 조회를 막을 수 있다.
즉시 로딩 ❓Member와 Team을 같이 쓰는 빈도가 높을 경우에는 어떻게 해야 할까?
즉시 로딩 EAGER를 사용해서 함꼐 조회 fetch = FetchType.EAGER
/*Member*/ @Entity public class Member{ ... @ManyToOne(fetch = FetchType.EAGER) //즉시로딩 사용  @JoinColumn(name=&#34;TEAM_ID&#34;) private Team team; ... } ... Member m = em.</div><div class="post-footer">
        <a href="/posts/jpa-proxy-and-management/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-advanced-mapping/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-advanced-mapping/">고급 매핑</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 상속관계 매핑   관계형 데이터베이스는 상속 관계X 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑  Album, Movie, Book은 모두 id, name, price를 가지고 있다(공통 변수)
슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법 1. 조인전략  Item, Album에 PK,FK가 같아 각각의 테이블에 insert가 수행하고 Item내에 타입을 구분하는 컬럼을 만들어서 구해온다. 장점  정규화도 되어있고, 제약조건을 부모에 걸어 맞출 수 있다.  ex: Order 테이블에서 특정 아이템(영화)의 가격을 볼 때 ITEM 테이블만 봐도 된다.   저장공간 효율화   단점  조회시 조인이 많을 경우 성능 저하 조회 쿼리가 복잡함 데이터 저장시 INSERT SQL 2번 호출(큰 문제는 아님)   조인이 많아도 조건이 잘 걸려있을 경우 성능 하락이 크지 않고 저장공간이 효율적으로 되기에 오히려 더 좋을 수 있다는 점을 고려해야 한다.  2. 단일 테이블 전략 (default)  논리모델을 한 테이블로 합쳐버리는 방법 한 테이블에 다 넣어 놓고 어떤 테이블인지 구분하는 컬럼(ex:DTYPE)을 통해 구분한다. 테이블은 ITEM 테이블 하나만 관리된다. 성능에서 우위를 가질 수 있다. (select or insert가 한번에 수행으로 된다.) @DiscriminatorColumn 이 필수로 들어간다(기입하지 않아도 자동으로 들어감) 장점  조인이 필요 없기에 일반적으로 조회 성능이 빠름 조회 쿼리가 단순함   단점  자식 엔티티가 매핑한 컬럼은 모두 nullable 해야 한다. 단일 테이블에 모든 것을 저장하기에 테이블이 커질 수 있고 상황에 따라서 조회성능이 더 느려질 수 있다. (임계점을 넘을 저도의 상황은 거의 오지 않는다.)    3. 구현 클래스마다 테이블 전략  각각의 테이블마다 별개로 만들어서 따로 관리 ITEM 테이블을 생성하지 않고 ALBUM, MOVIE, BOOK 테이블에서 각각 id, name, price 필드를 가지고 있다. @DiscriminatorColumn을 사용할 수 없다. (구분할 이유가 없다.) ITEM을 조회하면 ALBUM, MOVIE, BOOK 세개의 테이블을 UNION ALL으로 전부 조회해서 가져온다. (단점) 추천하지 않는 전략 (개발자, DBA 양측에서) 장점  서브 타입을 명확하게 구분해서 처리할 때 효과적 Not Null 제약조건 가능   단점  여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION SQL) 자식 테이블을 통합해서 쿼리하기 힘듬    2. 주요 어노테이션 @Inheritance(strategy = InheritanceType.XXX)
 JOINED : 조인전략 SINGLE_TABLE : 단일 테이블 전략 TABLE_PER_CLASS : 구현 클래스마다 테이블 전략  @DiscriminatorColumn(name = &ldquo;DTYPE&rdquo;)
 default : DTYPE 이라는 Column이 super class의 table에 생기고, DTYPE의 값은 sub class의 이름으로 지정된다. SingleTable 전략에서 없어도 DTYPE이 생성되기도 하는데, 그래도 운영상 써주자. 이 어노테이션은 상위 클래스(Item)에서 명시된다. 데이터베이스의 상위 테이블(Item 테이블)에게 구분자 역할을 DTYPE 칼럼을 넣어준다. 애노테이션의 name 속성으로 컬럼명을 바꿔줄 수 있다 (이름속성으로 쓰자).  @DiscriminatorValue(“XXX”)
 이 어노테이션은 하위 클래스(ALBUM, MOVIE, BOOK)에서 사용된다. 상위 테이블(ITEM 테이블)을 조회할때 DTYPE 칼럼에 사용되는 value를 설정해주는 기능이다. 애노테이션을 사용하지 않을 경우 기본 Default 값인 Entity 이름으로 value값이 채워지게 된다. default: classname  3. @MappedSuperclass   공통 매핑 정보가 필요할 때 사용(id, name)  ex: 모든 테이블에 row 생성일, 수정일을 등록해야하는 경우(createdAt, updatedAt)     상속관계 매핑이 아니다. 엔티티도 아니고, 테이블과 매핑되지도 않는다. 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공 부모타입으로 조회, 검색 불가 직접 생성해서 사용할 일이 없으므로 추상클래스 추천  @Entity클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
@MappedSuperclass public abstract class BaseEntity { private String createdBy; private LocalDateTime createdDate; private String modifiedBy; private LocalDateTime lastModifiedDate; } @Entity public class Member extends BaseEntity { } @Entity public class Team extends BaseEntity { } Member member = new Member(); member.</div><div class="post-footer">
        <a href="/posts/jpa-advanced-mapping/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-mapping-various-associations/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-mapping-various-associations/">다양한 연관관계 매핑</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 연관관계 매핑시 고려사항 3가지   다중성  다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany → 다대다는 실무에서 사용하면 안된다. 단방향, 양방향  테이블  외래 키 하나로 양쪽 조인 가능 방향이라는 개념이 없음 양쪽이 서로 참조하면 양방향       연관관계의 주인  테이블은 외래 키 하나로 두 데이블의 연관관계를 찾음 객체 야방향 관계는 A → B, B → A 처럼 참조가 2군데 연관관계의 주인: 외래 키를 관리하는 참조 주인의 반대편 : 외래 키에 영향을 주지않고 단순 조회(참조)만 가능    2. 다대일 [N:1]  다대일(N:1) 단방향   ERD
다대일(N:1)단방향
 가장 많이 사용하는 연관관계 다대일의 반대는 일대다    다대일 양방향   ERD
 외래 키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발 연관관계가 주인이 아닌 쪽은 단순 조회만 가능하기에 필드만 추가해주면 된다.  @OneToMany private List&lt;Member&gt; members = new ArrayList&lt;&gt;();   3. 일대다 [1:N]  일(One)이 연관관계의 주인이다. → 권장하는 방법은 아니다. 실무에서도 거의 사용되지 않음
  ERD
 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있다. 객체와 테이블의 차이 떄문에 반대편 테이블의 외래키를 관리하는 특이한 구조    권장하지 않는 이유   테이블에서는 항상 다(N) 쪽에 외래키가 있기 때문에 패러다임충돌이 있다.
  @JoinColumn 을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다. (중간에 테이블을 하나 추가함)
  실무에서는 테이블이 수십개 이상 운영이 되는데, 관리 및 트레이싱이 어렵다.
→ Ex) 일대다(1:N)에서 저장(save)이 될 때 양쪽 객체를 저장한 뒤 update query를 통해 외래키 설정(3번이나 수행)
   결론: 기본은 다대일(N:1)로 구현하다 필오에 의해 양방향 다대일(N:1) 관계를 수립하도록 하자.
 일대다(1:N)양방향   ERD
  이런 매핑은 공식적으로는 존재하지 않는다.
  @JoinColumn(insertable=false, updatable=false)
/* 팀(Team) */ public class Team{ ... @OneToMany @JoinColumn(name=&#34;TEAM_ID&#34;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); ... } /* 멤버(Member) */ public class Member{ ... @ManyToOne @JoinColumn(name=&#34;TEAM_ID&#34;, insertable=false, updatable=false) private Team team; ... } → Member ENtity의 team field가 읽기전용 field가 됐다.
     읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용하자.  4. 일대일(1:1)   주 테이블이나 대상 테이블 중에 외래 키 선택 가능 외래키에 데이터베이스 유니크 제약조건 추가 다대일 연관관계와 동일하게 외래키가 있는곳이 연관관계의 주인 연관관계의 주인이 아닌 곳에 mappedBy를 넣어준다. 정리  주 테이블에 외래 키  주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매핑 정리 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점 : 값이 없으면 외래 키에 null 허용   대상 테이블의 외래 키  대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 단점 : 주 테이블에는 외래 키가 없기 때문에 대상 테이블이 있는지 없는지 알 수 없기 때문에 즉시로딩이 무조건 된다.      5. 다대다 [N:M]   실무에서는 거으 ㅣ사용하지도 않고 추천하지도 않는 연관관계 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능 @ManyToMany 사용 @JoinTable로 연결 테이블 지정  다대다 매핑의 한계  편리해 보이지만 실무에서 사용안함 연겵 테이블이 단순히 연결만 하고 끝나지 않음 주문시간, 수량 같은 데이터가 들어올 수 있음.</div><div class="post-footer">
        <a href="/posts/jpa-mapping-various-associations/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-mapping-basics/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-mapping-basics/">연관관계 매핑 기초</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 연관관계의 필요성  : 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.
2. 객체를 테이블에 맞춰 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다. 2-1. 객체를 테이블에 맞추어 모델링(연관관계가 없는 객체)   객체를 테이블에 맞추어 모델링 (참조 대신에 외래 키를 그대로 사용)
/* 회원(Member) 엔티티*/ @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = &#34;USERNAME&#34;) private String name; @Column(name = &#34;TEAM_ID&#34;) private Long teamId; } /* 팀(Team) 엔티티 */ @Entity public class Team{ @Id @GeneratedValue private Long id; private String name; }  객체를 위와 같이 테이블에 맞춰 모델링을 할 경우 생기는 문제는 무엇일까?      객체를 테이블에 맞춰 모델링 했을 경우 DB에 저장&amp;조회하는 로직
/* 팀과 멤버를 저장하는 로직 */ Team team = new Team(); team.setName(&#34;teamA&#34;); em.persist(team); Member member = new Member(); member.setName(&#34;mamber1&#34;); member.setTeamId(team.getId()); em.persist(member);  외래키 식별자를 직접다루고 있는데, 이럴 경우 문제는? → 조회할 때 역시 해당 외래키를 가지고 조인 쿼리를 직접 짜야 한다. Q. member1 이 소속된 팀 정보를 조회하려면 어떻게 해야하는가?  Member findMember = em.find(Member.class, member.getId()); Long findTeamId = findMember.getTeamId(); Team findTeam = em.find(Team.class, findTeamId);  매번 member를 우선 조회한 뒤 외래키를 뽑아 그것으로 팀의 정보를 조회해야 한다. → 협력관계를 만들 수 없다.    Hibernate: create table Member ( MEMBER_ID bigint not null, TEAM_ID bigint, USERNAME varchar(255), primary key (MEMBER_ID) ) Hibernate: create table Team ( TEAM_ID bigint not null, name varchar(255), primary key (TEAM_ID) )  결론: 외래키를 직접 관리하는 테이블에 맞춘 객체 모델링은 객체간의 협력관계를 만들 수 없고, 객체가 참조를 통해 연관객체를 찾는 다는 사상을 적용할 수 없다. 이 말은 객체지향 프로그래밍의 패러다임을 정면으로 반박하는 것.
  객체 지향 모델링 (객체 연관관계 사용)
   객체 지향적으로 엔티티 설계(객체 연관관계 사용)
/* 회원(Member) 엔티티*/ @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = &#34;USERNAME&#34;) private String name; @ManyToOne @JoinColumn(name = &#34;team_id&#34;) private Team team; ... getter, setter }  @ManyToOne @JoinColumn 을 통해 멤버(Member)에서 팀(Team)을 참조하도록 헀다.    Team team = new Team(); team.setName(&#34;teamA&#34;); em.persist(team); Member member = new Member(); member.setName(&#34;mamber1&#34;); member.setTeam(team); em.persist(member); em.flush(); em.clear(); Member findMember = em.find(Member.class, member.getId()); Team findTeam = member.getTeam(); 
3. 양방향 연관관계와 연관관계 주인1 - 기본    단방향에서 양방향이 된다는 것의 의미는 양측에서 서로 참조할 수 있다는 것이다. 기존 단방향에서는 Member 에서 getTeam()을 통해 Team 엔티티를 참조할 수 있지만 Team 에서는 Member 를 참조할 수 없었다. 하지만 테이블 연관관계에서는 외래키를 가지고 양측에서 서로를 참조할 수 있다.
  Team 객체에 members라는 List를 추가해서 양방향 연관관계를 만들어준다.
@Entity public class Team{ ... @OneToMany(mappedBy = &#34;team&#34;) private List&lt;Member&gt; members = new ArrayList&lt;&gt;(); ... }     추가한 members 를 확인하는 코드를 작성해보자.
Member findMember = em.find(Member.class, member.getId()); List&lt;Member&gt; members = findMember.getTeam().getMembers(); for (Member member1 : members) { System.out.println(&#34;member1.getName() = &#34; + member1.getName()); // member1.getName() = mamber1 }  이제 반대방향으로도 객체 그래프 탐색이 가능해졌다.    연관관계의 주인과 mappedBy  mappedBy = 연관관계의 개념에 대해 이해를 어렵게 만드는 주범! 객체와 테이블간 연관관계를 맺는 차이를 이해해야 한다.  객체와 테이블이 관계를 맺는 차이란?  객체 연관관계 = 2개  회원 → 팀 연관관계 1개(단방향) 팀 → 회원 연관관계 1개(단방향)   테이블 연관관계 = 1개  회원 ←→ 팀의 연관관계 1개(양방향)    결국 양방향 관계란  객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다.</div><div class="post-footer">
        <a href="/posts/jpa-mapping-basics/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-entity-mapping/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-entity-mapping/">엔티티매핑</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">엔티티 매핑 소개   객체와 테이블 매핑 : @Entity , @Table 필드와 컬럼 매핑 : @Column 기본 키 매핑 : @Id 연관관계 매핑 : @ManyToOne , @JoinColumn  JPA로 데이터베이스 스키마를 자동 생성하는 방법 JPA로 어플리케이션 로딩 시점에 테이블을 생성할 수 있다. 일일이 스키마를 수정하기 힘든 개발 환경에서 사용하면 좋다. 운영에서 쓰려면 절대 그대로 사용해서 안 되고 다듬어야 한다.
엔티티 매핑을 해놓으면, JPA가 어플리케이션 실행 시점에 DDL을 자동 생성하여 수행한다. 객체 중심으로 개발해 놓기만 하면 되니 테이블을 건드릴 필요 없다. 게다가 데이터베이스 방언(dialect)를 활용해 DB에 알맞는 DDL을 만든다.
스프링 부트에선 spring.jpa.hibernate.ddl-auto 속성으로 스키마 생성 전략을 설정할 수 있다.
  create : 기존 테이블 삭제 후 다시 생성 (DROP -&gt; CREATE)
  create-drop : create + 종료 시점 drop (DROP -&gt; CREATE -&gt; DROP)
  update : 추가된 사항만 반영, 이미 반영된 것을 지우는 작업은 불가능! (특히 운영DB에서 사용하면 안 됨)
  validate : 엔티티와 테이블이 알맞게 매핑되었는지 검증
  none : 사용하지 않음
  로컬 서버에서 자유롭게 사용하고, 여러 명의 개발자가 사용하는 서버에선 사용하지 않는 게 좋다.
create / create-drop은 기존 테이블을 드랍하기 때문에 기존 데이터를 날려버리고, update는 alter문을 실행하면서 테이블 lock을 걸기 때문에 조심해야 한다.
실무에서는 validate 를 사용
1. 객체와 테이블 매핑 @Entity   @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의  기본 생성자 필수 (파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용X    @Entity 속성 정리   속성 : name  JPA에서 사용할 엔티티 이름을 지정한다. 기본값 : 클래스 이름을 그대로 사용 (예: Member) 같은 클래스 이름이 없으면 가급적 기본값을 사용한다.    주의할 점
 기본 생성자 필수 (public or protected) final 클래스 / inner 클래스 / enum / interface 에는 사용 불가능 DB 컬럼과 매핑될 필드에 final 사용 불가능  @Table   @Table은 엔티티와 매핑할 테이블 지정     속성 기능 기본값     name 매핑할 테이블 이름 엔티티 이름을 사용   catalog 데이터베이스 catalog 매핑    schema 데이터베이스 schema 매핑    uniqueConstrints (DDL) DDL 생성 시에 유니크 제약 조건 생성     2. 데이터베이스 스키마 자동 생성  데이터베이스 스키마 자동 생성  DDL을 어플리케이션 실행 시점에 자동 생성 테이블 중심 → 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성된 DDL은 개발 장비에서만 사용 생성된 DDL은 운영서버에서는 사용되지 않거나 적절히 다듬은 후 사용  데이터베이스 스키마 자동 생성 - 속성  hibernate.hbm2ddl.auto  create : 기존 테이블 삭제 후 다시 생성 (DROP + CREATE) create-drop : create와 같으나 종료시점에 테이블 DROP update : 변경분만 반영 (운영DB에는 사용하면 안됨) validate : 엔티티와 테이블이 정상 매핑되었는지만 확인 none : 사용하지 않음    DDL 생성 기능  제약조건 추가 : 회원 이름 필수 , 10자 초과 X  @Column(nullable = false, length = 10)   유니크 제약조건 추가  @Table(uniqueConstraints = {@UniqueCOnstraint(name = &quot;NAME_AGE_UNIQUE&quot;, columnNames = {&quot;NAME&quot;, &quot;AGE&quot;})})   DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.</div><div class="post-footer">
        <a href="/posts/jpa-entity-mapping/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><div class="featured-image-preview">
            <a href="/posts/jpa-persistence-management-works/"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/JPA/jpa.png"
        data-srcset="/images/JPA/jpa.png, /images/JPA/jpa.png 1.5x, /images/JPA/jpa.png 2x"
        data-sizes="auto"
        alt="/images/JPA/jpa.png"
        title="/images/JPA/jpa.png" /></a>
        </div><h1 class="single-title" itemprop="name headline">
        <a href="/posts/jpa-persistence-management-works/">영속성관리 - 내부 동작 방식</a>
    </h1><div class="post-meta"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jaeyeon</a></span>&nbsp;<span class="post-publish">published on <time datetime="2021-12-29">2021-12-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/jpa/"><i class="far fa-folder fa-fw"></i>JPA</a></span></div><div class="content">1. 영속성 컨텍스트  웹 어플리케이션이 구동하는 시점에 EntityManagerFactory 를 생성하여 가지고 있으며, 사용자의 요청이 있을 때 EntityManager를 생성하여 커넥션 풀(Connection Pool)을 사용해서 DB를 핸들링 하게 된다.  영속성 컨텍스트란?   엔티티를 영구 저장하는 환경
  EntityManager.persist(entity);
→ DB에 저장한다기 보다는 영속성 컨텍스트를 통해 엔티티를 영속화 한다는 의미
 영속성 컨텍스트에 엔티티를 저장한다는 말    영속성 컨텍스트는 논리적인 개념
  눈에 보이지 않는다.
  엔티티 매니저를 통해서 영속성 컨텍스트에 접근
 J2SE 환경    엔티티의 생명 주기  비영속(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속(managed): 영속성 컨텍스트에 관리되는 상태 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed): 삭제된 상태  비영속 : JPA에 관계없이 객체 생성만 된 상태
// 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); 
영속 // 객체를 생성한 상태(비영속) Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); // 객체를 저장한 상태(영속) em.persist(member); 
준영속, 삭제 // 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태 em.detach(member); // 객체를 삭제한 상태(삭제) em.remove(member);  준영속: 영속성 컨텍스트에서 삭제하는 것 삭제는 실제로 DB에서 해당 ROW를 삭제하는 것  2. 영속성 컨텍스트의 이점 1. 1차 캐시 Member member = new Member(); member.setId(&#34;member1&#34;); member.setUsername(&#34;회원1&#34;); //1차 캐시에 저장됨 em.persist(member); //1차 캐시에서 조회 Member findMember = em.find(Member.class, &#34;member1&#34;);  조회 시 영속 컨텍스트안에서 1차 캐시를 조회 후 해당 엔티티가 있을 경우 캐시를 조회 해 온다. 조회 시 영속 컨텍스트 안에서 1차 캐시를 조회 후 해당 엔티티가 없을 경우 데이터베이스에서 조회해 온다. 데이터베이스 트랜잭션 내부에서 만들고 종료되기 때문에 하나의 비즈니스 로직이 종료될 경우 1차캐시는 다 사라지기 때문에 큰 도움이 되지 않는다. (비즈니스 로직이 복잡해 질 수록 효과는 커진다.)  2. 동일성(identity) 보장 Member findMember = em.find(Member.class, 100L); Member findMember2 = em.find(Member.class, 100L); System.out.println(findMember == findMember2); // true : 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
 참고: 트랜잭션의 격리수준이 궁금하면 트랜잭션이 보장해야 하는 ACID를 기억하자.
 3. 엔티티 등록 - 트랜잭션을 지원하는 쓰지지연 Member member = new Member(150L, &#34;A&#34;); Member member2 = new Member(160L, &#34;B&#34;); em.persist(member); em.persist(member2); // 엔티티 등록은 아직 수행되지 않는다. (쓰지 지연)  System.out.println(&#34;=========&#34;); tx.commit(); // 에티티 등록은 이 떄 동시에 수행된다. 
memberA와 memberrB는 둘 다 쓰기지연 SQL저장소에 저장되어있고 실제 DB에 적용은 안된 상태
commit() 시점에 쓰기지연 SQL에 저장된 쿼리들을 다 실행시켜서 DB에 적용한다.
쓰기 지연을 사용하는 이유
-&gt; 버퍼링 기능이 제공
&lt;property name=&#34;hibernate.jdbc.batch_size&#34; value=&#34;10&#34;/&gt; -&gt; 10개씩 쌓일때마다 적용하게 하는 기능
-&gt; 쿼리를 여러번 날리지 않고 최적화가 가능하다.
4. 엔티티 수정 - 변경감지(Dirty Checking) transaction.begin(); //엔티티 조회 Member findMember = em.find(Member.class, &#34;memberA&#34;); //영속 엔티티 데이터 수정 findMember.setUsername(&#34;hi&#34;); findMember.setAge(10); transaction.commit(); → 1차 캐시안에는 @Id, Entity , 스냅샷 이 있다. 여기서 스냅샷 은 최초로 영속성 컨텍스트(1차캐시)에 들어오는순간 스냅샷을 찍어서 저장해둔다.
→ JPA는 트랜잭션이 커밋(commit)되는 순간 엔티티와 스냅샷을 모두 비교한다.
→ 변경된 것이 있을 경우 쓰기지연 SQL 저장소 에 업데이트 쿼리를 저장하고 수행하게 된다.
5. 엔티티 삭제 //삭제 대상 엔티티 조회 Member member = em.find(Member.class, &#34;memberA&#34;); em.remove(member);//엔티티 삭제 
3. 플러시(flush) : 영속성 컨텍스트의 변경을 데이터베이스에 반영(sync)
  플러시 발생
 변경 감지 수정된 엔티티 쓰기지연 SQL 저장소에 등록 쓰기 지연 SQL저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)    영속성 컨텍스트를 플러시 하는 방법</div><div class="post-footer">
        <a href="/posts/jpa-persistence-management-works/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/jpa/">JPA</a>,&nbsp;<a href="/tags/hibernate/">Hibernate</a></div></div>
</article></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.91.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Jaeyeon</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"data":{"id-1":"Life of record"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"typeit":{"cursorChar":"|","cursorSpeed":500,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
