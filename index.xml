<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>📚 | Dev Blog</title>
        <link>https://jaeyeonme.github.io/</link>
        <description>📚 | Dev Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 31 Dec 2021 13:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://jaeyeonme.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>QueryDSL 중급 문법</title>
    <link>https://jaeyeonme.github.io/posts/querydsl-intermediate-grammer/</link>
    <pubDate>Fri, 31 Dec 2021 13:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/querydsl-intermediate-grammer/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/querydsl.png" referrerpolicy="no-referrer">
            </div>프로젝션과 결과 반환 - 기본 프로젝션 : select 대상 지정
프로젝션 대상이 하나
List&lt;String&gt; result = queryFactory .select(member.username) .from(member) .fetch();  프로젝션 대상이 하나면 타입을 명확하게 지정할 수 있음(List&lt;String&gt;) 프로젝션 대상이 둘 이상이면 튜플이나 DTO로 조회  튜플 조회 프로젝션 대상이 둘 이상일 때 사용
com.querydsl.core.Tuple
List&lt;Tuple&gt; result = queryFactory .select(member.username, member.age) .from(member) .fetch(); for (Tuple tuple : result) { String username = tuple.get(member.username); Integer age = tuple.get(member.age); System.out.println(&#34;username = &#34; + username); System.out.println(&#34;age = &#34; + age); }  Tuple 은 리포지토리 계층안에서 쓰는 정도는 괜찮지만 그 밖의 계층에서는 DTO로 변환해서 쓰는 것이 좋다. → Tuple 도 결국 Querydsl에 종속적이기 떄문  프로젝션과 결과 반환 - DTO 조회 순수 JPA에서 DTO 조회 위에서 select 절에서 대상을 지정(프로젝션)해서 가져오고 싶을때 그 대상이 둘 이상이면 Tuple로 가져왔었다. 하지만, 그 외 계층으로 가져갈 때는 DTO로 가져가는게 좋다. 우선 순수 JPA를 이용해서 DTO로 조회하는 코드를 작성해보자.
MemberDto
@Data @NoArgsConstructor public class MemberDto { private String username; private int age; public MemberDto(String username, int age) { this.username = username; this.age = age; } } 
순수 JPA에서 DTO 조회 코드
@Test public void findDtoByJPQL() { List&lt;MemberDto&gt; result = em.createQuery(&#34;select new study.querydsl.dto.MemberDto(m.username, m.age) from Member m&#34;, MemberDto.class) .getResultList(); for (MemberDto memberDto : result) { System.out.println(&#34;memberDto = &#34; + memberDto); } }  순수 JPA에서 DTO를 조회할 때는 new 명령어를 사용해야 함 DTO의 package이름을 다 적어줘야해서 지저분함 생성자 방식만 지원함  QueryDSL 빈 생성 (Bean Population) 결과를 DTO반환할 떄 사용하며 3가지 방법이 존재한다.
 프로퍼티 접근 필드 직접 접근 생성자 사용  프로퍼티 접근 - Setter
@Test public void findDtoBySetter() { List&lt;MemberDto&gt; result = queryFactory .select(Projections.bean(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) { System.out.println(&#34;memberDto = &#34; + memberDto); } }  Projections.bean(주입대상클래스, 프로퍼티1, 프로퍼티2&hellip;)방식으로 프로퍼티에 값을 주입  필드 직접 접근
@Test public void findDtoByField() { List&lt;MemberDto&gt; result = queryFactory .select(Projections.fields(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) { System.out.println(&#34;memberDto = &#34; + memberDto); } }  Getter, Setter가 없어도 필드에 바로 값을 주입 Projections.fields(주입대상클래스, 필드1, 필드2&hellip;)  필드 직접 접근 - 별칭이 다를 때
@Test public void findUserDtoByField() throws Exception { QMember memberSub = new QMember(&#34;memberSub&#34;); List&lt;UserDto&gt; result = queryFactory .select(Projections.fields(UserDto.class, member.username.as(&#34;name&#34;), ExpressionUtils.as(JPAExpressions .select(memberSub.age.max()) .from(memberSub), &#34;age&#34;) )) .from(member) .fetch(); for (UserDto memberDto : result) { System.out.println(&#34;memberDto = &#34; + memberDto); } }  필드나 프로퍼티명 접근 생성방식에서 이름이 다를 때 해결방안을 as(name)을 이용해서 해결한다. ExpressionUtils.as(source,alias) : 필드나 서브 쿼리에 별칭 적용 username.as(&quot;memberName&quot;) : 필드에 별칭 적용  생성자 적용
@Test public void findDtoByConstructor() { List&lt;MemberDto&gt; result = queryFactory .select(Projections.constructor(MemberDto.class, member.username, member.age)) .from(member) .fetch(); for (MemberDto memberDto : result) { System.out.println(&#34;memberDto = &#34; + memberDto); } } 
프로젝션과 결과 반환 - @QueryProjection 프로젝션결과를 반환할 DTO에 @QueryProjection 을 생성자에 붙혀준 뒤 gradle → tasks → other → compileQuerydsl 을 통해 DTO도 Q타입으로 생성해 준다.
생성자 + @QueryProjection @Data @NoArgsConstructor public class MemberDto { private String username; private int age; @QueryProjection public MemberDto(String username, int age) { this.username = username; this.age = age; } }  ./gradlew compileQuerydsl QMemberDto 생성 확인  @QueryProjection 활용 @Test public void findDtoByQueryProjection() throws Exception{ List&lt;MemberDto&gt; result = queryFactory .]]></description>
</item><item>
    <title>QueryDSL 기본 문법</title>
    <link>https://jaeyeonme.github.io/posts/querydsl-basic-grammer/</link>
    <pubDate>Fri, 31 Dec 2021 12:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/querydsl-basic-grammer/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/querydsl.png" referrerpolicy="no-referrer">
            </div>JPQL VS QueryDSL QueryDSL vs JPQL @Test public void startJQPL() { // member1을 찾아라  String qlString = &#34;select m from Member m &#34; + &#34;where m.username = :username&#34;; Member findMember = em.createQuery(qlString, Member.class) .setParameter(&#34;username&#34;, &#34;member1&#34;) .getSingleResult(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); } @Test public void startQuerydsl() { // member1을 찾아라.  JPAQueryFactory queryFactory = new JPAQueryFactory(em); QMember m = new QMember(&#34;m&#34;); Member findMember = queryFactory .select(m) .from(m) .where(m.username.eq(&#34;member1&#34;)) // 파라미터 바인딩 처리  .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); }  EntityManager 로 JPAQueryFactory 생성 Querydsl은 JPQL 빌더 JPQL : 문자(실행 시점 오류), Querydsl : 코드(컴파일 시점 오류) JPQL : 파라미터 바인딩 직접, Querydsl : 파라미터 바인딩 자동 처리  JPAQueryFactory를 필드로 @SpringBootTest @Transactional public class QuerydslBasicTest { @Autowired EntityManager em; JPAQueryFactory queryFactory; @BeforeEach public void before() { queryFactory = new JPAQueryFactory(em); // ... 	} @Test public void startQuerydsl() { // member1을 찾아라.  QMember m = new QMember(&#34;m&#34;); Member findMember = queryFactory .select(m) .from(m) .where(m.username.eq(&#34;member1&#34;)) // 파라미터 바인딩 처리  .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); } }  JPAQueryFactory를 필드로 제공하면 동시성 문제는 어떻게 될까? 동시성 문제는 JPAQueryFactory를 생성할 때 제공하는 EntityManager(em)에 달려있다. 스프링 프레임워크는 여러 쓰레드에서 동시에 같은 EntityManager에 접근해도, 트랜잭션 마다 별도의 영속성 컨텍스트를 제공하기 때문에, 동시성 문제는 걱정하지 않아도 된다.  기본 Q-Type 활용 Q클래스 인스턴스를 사용하는 2가지 방법 QMember qMember = new QMember(&#34;m&#34;); //별칭 직접 지정 QMember qMember = QMember.member; //기본 인스턴스 사용 
기본 인스턴스를 static import와 함께 사용 @Test public void startQuerydsl() { Member findMember = queryFactory .select(QMember.member) .from(QMember.member) .where(QMember.member.username.eq(&#34;member1&#34;)) // 파라미터 바인딩 처리  .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); } 
다음 설정을 추가하면 실행되는 JPQL을 볼 수 있다.
spring.jpa.properties.hibernate.use_sql_comments: true 
참고: 같은 테이블을 조인해야 하는 경우가 아니면 기본 인스턴스를 사용하자
검색 조건 쿼리 기본 검색 쿼리 @Test public void search() { Member findMember = queryFactory .selectFrom(member) .where(member.username.eq(&#34;member1&#34;) .and(member.age.eq(10))) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); }  검색 조건은 .and() , .or() 를 메서드 체인으로 연결할 수 있다. select 와 from 은 selectFrom 으로 합칠 수 있다.  JPQL이 제공하는 모든 검색 조건 제공 member.username.eq(&#34;member1&#34;) // username = &#39;member1&#39; member.username.ne(&#34;member1&#34;) //username != &#39;member1&#39; member.username.eq(&#34;member1&#34;).not() // username != &#39;member1&#39;  member.username.isNotNull() //이름이 is not null  member.age.in(10, 20) // age in (10,20) member.age.notIn(10, 20) // age not in (10, 20) member.age.between(10,30) // between 10, 30  member.age.goe(30) // age &gt;= 30 member.age.gt(30) // age &gt; 30 member.age.loe(30) // age &lt;= 30 member.age.lt(30) // age &lt; 30  member.username.like(&#34;member%&#34;) // like 검색 member.username.contains(&#34;member&#34;) // like ‘%member%’ 검색 member.username.startsWith(&#34;member&#34;) // like ‘member%’ 검색 
AND 조건을 파라미터로 처리 @Test public void searchAndParam() { Member findMember = queryFactory .selectFrom(member) .where( member.username.eq(&#34;member1&#34;), member.age.eq(10)) .fetchOne(); assertThat(findMember.getUsername()).isEqualTo(&#34;member1&#34;); }  where() 에 파라미터로 조건검색을 추가하면 AND 조건이 추가됨 이 경우 null 값은 무시 → 메서드 추출을 활용해서 동적 쿼리를 깔끔하게 만들 수 있음 → 뒤에서 설명  결과 조회  fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환 fetchOne() : 단 건 조회  결과가 없으면 : null 결과가 둘 이상이면 : com.querydsl.core.NonUniqueResultException   fetchFirst() : limit(1).fetchOne() fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행 fetchCount() : count 쿼리로 변경해서 count 수 조회  // List List&lt;Member&gt; fetch = queryFactory .selectFrom(member) .]]></description>
</item><item>
    <title>확장 기능</title>
    <link>https://jaeyeonme.github.io/posts/spring-data-jpa-extension/</link>
    <pubDate>Fri, 31 Dec 2021 10:30:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/spring-data-jpa-extension/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/spring-data-jpa.png" referrerpolicy="no-referrer">
            </div>1. 사용자 정의 리포지토리 구현 사용자 정의 리포지토리 구현  스프링 데이터 JPA 리포지토리는 인터페이스만 정의하고 구현체는 스프링이 자동 생성 스프링 데이터 JPA가 제공하는 인터페이를 직접 구현하면 구현해야 하는 기능이 너무 많음 다양한 이유로 인터페이스의 메서드를 직접 구현하고 싶다면?  JPA 직접 사용(EntityManager) 스프링 JDBC Template 사용 MyBatis 사용 데이터베이스 커넥션 직접 사용 등등.. QueryDSL 사용    사용자 정의 인터페이스
public interface MemberRepositoryCustom { List&lt;Member&gt; findMemberCustom(); } 
사용자 정의 인터페이스 구현 클래스
@RequiredArgsConstructor public class MemberRepositoryImpl implements MemberRepositoryCustom { private final EntityManager em; @Override public List&lt;Member&gt; findMemberCustom() { return em.createQuery(&#34;select m from Member m&#34;) .getResultList(); } } 
사용자 정의 인터페이스 상속
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepositoryCustom { } 
사용자 정의 메서드 호출 코드
List&lt;Member&gt; result = memberRepository.findMemberCustom(); 
사용자 정의 구현 클래스
 규칙 : 리포지토리 인터페이스 이름 + Impl 스프링 데이터 JPA가 인식해서 스프링 빈으로 등록  Impl 대시 다른 이름으로 변경하고 싶으면?
XML 설정
&lt;repositories base-package=&#34;study.datajpa.repository&#34; repository-impl-postfix=&#34;Impl&#34; /&gt; 
JavaConfig 설정
@EnableJpaRepositories(basePackages = &#34;study.datajpa.repository&#34;, repositoryImplementationPostfix = &#34;Impl&#34;) 
참고 실무에서는 주로 QueryDSL이나 SpringJdbcTemplate을 함께 사용할 때 사용자 정의 리포지토리 기능 자주 사용 항상 사용자 정의 리포지토리가 필요한 것은 아니다. 그냥 임의의 리포지토리를 만들어도 된다.
예를들어 MemberQueryRepository를 인터페이스가 아닌 클래스로 만들고 스프링 빈으로 등록해서 그냥 직접 사용해도 된다. 물론 이 경우 스프링 데이터 JPA와는 아무런 관계 없이 별도로 동작한다.
사용자 정의 리포지토리 구현 최신 방식 스프링 데이터 2.x 부터는 사용자 정의 구현 클래스에 리포지토리 인터페이스 이름 + Impl 을 적용하는 대신에 사용자 정의 인터페이스 명 + Impl 방식도 지원한다.
예를 들어 위 예제의 MemberRepositoryImpl 대신에 MemberRepositoryCustomImpl 같이 구현해도 된다.
최신 사용자 정의 인터페이스 구현 클래스 예제
@RequiredArgsConstructor public class MemberRepositoryCustomImpl implements MemberRepositoryCustom { private final EntityManager em; @Override public List&lt;Member&gt; findMemberCustom() { return em.createQuery(&#34;select m from Member m&#34;) .getResultList(); } } 기존 방식보다 이 방식이 사용자 정의 인터페이스 이름과 구현 클래스 이름이 비슷하므로 더 직관적이다. 추가로 여러 인터페이스를 분리해서 구현하는 것도 가능하기 때문에 새롭게 변경된 이 방식을 사용하는 것을 더 권장한다.
2. Auditing  엔티티를 생성, 변경할 때 변경한 사람과 시간을 추적하고 싶으면?  등록일 수정일 등록자 수정자    순수 JPA 사용 우선 등록일, 수정일 적용
@Getter @MappedSuperclass public class JpaBaseEntity { @Column(updatable = false) private LocalDateTime createdDate; private LocalDateTime updatedDate; @PrePersist public void prePersist() { LocalDateTime now = LocalDateTime.now(); createdDate = now; updatedDate = now; } @PreUpdate public void preUpdate() { updatedDate = LocalDateTime.now(); } } JPA 주요 이벤트 어노테이션
 @PrePersist, @PostPersist @PreUpdate, @PostUpdate  스프링 데이터 JPA 사용 설정
@EnableJpaAuditing → 스프링 부트 설정 클래스에 적용해야함
@EntityListeners(AuditingEntityListener.class) → 엔티티에 적용
사용 어노테이션
 @CreatedDate @LastModifiedDate @CreatedBy @LastModifiedBy  스프링 데이터 Auditing 적용 - 등록일, 수정일
@EntityListeners(AuditingEntityListener.class) @MappedSuperclass @Getter public class BaseEntity { @CreatedBy @Column(updatable = false) private String createdBy; @LastModifiedBy private String lastModifiedBy; } 
스프링 데이터 Auditing 적용 - 등록자, 수정자
@EntityListeners(AuditingEntityListener.class) @MappedSuperclass @Getter public class BaseTimeEntity { @CreatedDate @Column(updatable = false) private LocalDateTime createdDate; @LastModifiedDate private LocalDateTime lastModifiedDate; } 
등록자, 수정자를 처리해주는 AuditorAware 스프링 빈 등록
@Bean public AuditorAware&lt;String&gt; auditorProvider() { return () -&gt; Optional.of(UUID.randomUUID().toString()); } 실무에서는 세션 정보나, 스프링 시큐리티 로그인 정보에서 ID를 받음]]></description>
</item><item>
    <title>쿼리 메소드</title>
    <link>https://jaeyeonme.github.io/posts/spring-data-jpa-query-method/</link>
    <pubDate>Fri, 31 Dec 2021 09:30:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/spring-data-jpa-query-method/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/spring-data-jpa.png" referrerpolicy="no-referrer">
            </div>1. 쿼리 메소드 기능  메소드 이름으로 쿼리 생성 NamedQuery @Query - 리파지토리 메소드에 쿼리 정의 파라미터 바인딩 반환 타입 페이징과 정렬 벌크성 수정 쿼리 @EntityGraph  쿼리 메소드 기능 3가지
 메소드 이름으로 쿼리 생성 메소드 이름으로 JPA namedQuery 호출 @Query 어노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의  메소드 이름으로 쿼리 생성 메소드 이름을 분석해서 JPQL 쿼리 실행
이름과 나이를 기준으로 회원을 조회하려면?
순수 JPA 리포지토리
public List&lt;Member&gt; findByUsernameAndAgeGreaterThen(String username, int age) { return em.createQuery(&#34;select m from Member m where m.username = :username and m.age &gt; :age&#34;) .setParameter(&#34;username&#34;, username) .setParameter(&#34;age&#34;, age) .getResultList(); } 
순수 JPA 테스트 코드
@Test public void findByUsernameAndAgeGreaterThen() { Member m1 = new Member(&#34;AAA&#34;, 10); Member m2 = new Member(&#34;AAA&#34;, 20); memberJpaRepository.save(m1); memberJpaRepository.save(m2); List&lt;Member&gt; result = memberJpaRepository.findByUsernameAndAgeGreaterThen(&#34;AAA&#34;, 15); assertThat(result.get(0).getUsername()).isEqualTo(&#34;AAA&#34;); assertThat(result.get(0).getAge()).isEqualTo(20); assertThat(result.size()).isEqualTo(1); } 
스프링 데이터 JPA
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age); }  스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행  스프링 데이터 JPA가 제공하는 쿼리 메소드 기능
 조회: find…By ,read…By ,query…By get…By,  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.query-methods.query-creation 예:) findHelloBy 처럼 &hellip;에 식별하기 위한 내용(설명)이 들어가도 된다.   COUNT: count…By 반환타입 long EXISTS: exists…By 반환타입 boolean 삭제: delete…By, remove…By 반환타입 long DISTINCT: findDistinct, findMemberDistinctBy LIMIT: findFirst3, findFirst, findTop, findTop3  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-query-result    참고 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야 한다. 그렇지 않으면 애플리케이션을 시작하는 시점에 오류가 발생한다. 이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점이다.
2. JPA NamedQuery JPA의 NamedQuery를 호출할 수 있음
@NamedQuery 어노테이션으로 Named 쿼리 정의
@Entity @NamedQuery( name = &#34;Member.findByUsername&#34;, query = &#34;select m from Member m where m.username = :username&#34; ) public class Member { ... } 
JPA를 직접 사용해서 Named 쿼리 호출
public class MemberRepository { public List&lt;Member&gt; findByUsername(String username) { ... return em.createNamedQuery(&#34;Member.findByUsername&#34;, Member.class) .setParameter(&#34;username&#34;, username) .getResultList(); } } 
스프링 데이터 JPA로 NamedQuery 사용
@Query(name = &#34;Member.findByUsername&#34;) List&lt;Member&gt; findByUsername(@Param(&#34;username&#34;) String username); @Query 를 생략하고 메서드 이름만으로 Named 쿼리를 호출할 수 있다.
스프링 데이터 JPA로 Named 쿼리 호출
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { // ** 여기 선언한 Member 도메인 클래스  List&lt;Member&gt; findByUsername(@Param(&#34;username&#34;) String username); }  스프링 데이터 JPA는 선언한 &ldquo;도메인 클래스 + .(점) + 메서드 이름&rdquo; 으로 Named 쿼리를 찾아서 실행 만약 실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략을 사용한다. 필요하면 전략을 변경할 수 있지만 권장하지 않는다.  참고 : https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-lookup-strategies    참고 스프링 데이터 JPA를 사용하면 실무에서 Named Query를 직접 등록해서 사용하는 일은 드물다. 대신 @Query 를 사용해서 리포지토리 메소드에 쿼리를 직접 정의한다.
3. @Query, 리포지토리 메소드에 쿼리 정의하기 메서드 JPQL 쿼리 작성 public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { @Query(&#34;select m from Member m where m.username = :username and m.age = :age&#34;) List&lt;Member&gt; findUser(@Param(&#34;username&#34;) String username, @Param(&#34;age&#34;) int age); }  @org.springframework.data.jpa.repository.Query 어노테이션을 사용 실행할 메서드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있음 JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있음 (매우 큰 장점!)  참고 실무에서는 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다.]]></description>
</item><item>
    <title>공통 인터페이스 기능</title>
    <link>https://jaeyeonme.github.io/posts/spring-data-jpa-common-interface/</link>
    <pubDate>Fri, 31 Dec 2021 09:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/spring-data-jpa-common-interface/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/spring-data-jpa.png" referrerpolicy="no-referrer">
            </div>1. 순수 JPA기반 리포지토리 만들기  기본 CRUD  저장 변경 → 변경감지 사용 삭제 전체 조회 단건 조회 카운트     참고: JPA에서 수정은 변경감지 기능을 사용하면 된다. 트랜잭션 안에서 엔티티를 조회한 다음에 데이터를 변경하면, 트랜잭션 종료 시점에 변경감지 기능이 작동해서 변경된 엔티티를 감지하고 UPDATE SQL을 실행한다.
 순수 JPA 기반 리포지토리
@Repository public class MemberJpaRepository { @PersistenceContext private EntityManager em; // Create (저장)  public Member save(Member member) { em.persist(member); return member; } // Delete (삭제)  public void delete(Member member) { em.remove(member); } // Read (조회)  public List&lt;Member&gt; findAll() { // JPQL  return em.createQuery(&#34;select m from Member m&#34;, Member.class) .getResultList(); } public Optional&lt;Member&gt; findById(Long id) { Member member = em.find(Member.class, id); return Optional.ofNullable(member); } public long count() { return em.createQuery(&#34;select count(m) from Member m&#34;, Long.class) .getSingleResult(); } public Member find(Long id) { return em.find(Member.class, id); } }  회원 리포지토리와 거의 동일하다.  2. 공통 인터페이스 설정 javaConfig 설정 - 스프링 부트 사용시 생략 가능 @Configuration @EnableJpaRepositories(basePackages = &#34;jpabook.jpashop.repository&#34;) public class AppConfig {}  스프링 부트 사용시 @SpringBootApplication 위치를 지정(해당 패키지와 하위 패키지 인식) 만약 위치가 달라지면 @EnableJpaRepositories 필요  스프링 데이터 JPA가 구현 클래스 대신 생성  org.springframework.data.repository.Repository 를 구현한 클래스는 스캔 대상  MemberRepository 인터페이스가 동작한 이유 실제 출력해보기(Proxy) memberRepository.getClass() → class com.sun.proxy.$ProxyXXX   @Repository 애노테이션 생략 가능  컴포넌트 스캔 스프링 데이터 JPA가 자동으로 처리 JPA 예외를 스프링 예외로 변환하는 과정도 자동으로 처리    3. 공통 인터페이스 적용 순수 JPA로 구현한 MemberJpaRepository 대신에 스프링 데이터 JPA가 제공하는 공통 인터페이스 사용
스프링 데이터 JPA 기반 Repository public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { }  Generic  T : 엔티티 타입 ID : 식별자 타입(PK)    4. 공통 인터페이스 분석  JpaRepository 인터페이스 : 공통 CURD 제공 제네릭은 &lt;엔티티 타입, 식별자 타입&gt; 설정  JpaRepository 공통 기능 인터페이스
public interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt; { ... } 
JpaRepository 를 사용하는 인터페이스
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { } 
공통 인터페이스 구성 주의
 T findOne(ID) → Optional&lt;T&gt; findById(ID) 변경  제네릭 타입
 T : 엔티티 ID : 엔티티의 식별자 타입 S : 엔티티와 그 자식 타입  주요 메서드
 save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다. delete(T) : 엔티티 하나르 삭제한다. 내부에서 EntityManager.remove() 호출 findById(ID) : 엔티티 하나를 조회한다. 내부에서 EntityManager.find() 호출 getOne(ID) : 엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference() 호출 findAll(...) : 모든 엔티티를 조회한다. 정렬(Sort)이나 페이징(Pageable) 조건을 파라미터로 제공할 수 있다.  참고: JpaRepository 는 대부분의 공통 메서드를 제공한다.]]></description>
</item><item>
    <title>객체지향 쿼리 언어 - 중급 문법</title>
    <link>https://jaeyeonme.github.io/posts/jpa-object-query-language2/</link>
    <pubDate>Thu, 30 Dec 2021 10:20:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/jpa-object-query-language2/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/jpa.png" referrerpolicy="no-referrer">
            </div>1. 경로 표현식  .(점)을 찍어 객체 그래프를 탐색하는 것 select m.username -&gt; 상태 필드 from Member m join m.team t -&gt; 단일 값 연관 필드 join m.orders o -&gt; 컬렉션 값 연관 필드 where t.name = &#39;팀A&#39; 
경로 표현식 용어 정리
 상태 필드(state field): 단순히 값을 저장하기 위한 필드(ex: m.usernmae) 연관 필드(association field): 연관관계를 위한 필드  단일 값 연관 필드:  @ManyToOne, @OneToOne: 대상이 엔티티(ex: m.team)  컬렉션 값 연관 필드:  @OneToMany, @ManyToMany, 대상이 컬렉션(ex m.orders)   경로 표현식 특징
  상태 필드(state field): 경로 탐색의 끝, 탐색x
  단일 값 연관 경로: 묵시적 내부 조인(inner join)발생, 탐색O
select m.team.name from Member m; //team에서 경로탐색이 더 가능하다(name)   컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X
  FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능
select m.username from Team t join t.members m;     실무에서는 명시적 조인을 사용하자.
조인은 SQL 튜닝에 중요 포인트
묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움
2. JPQL - 페치 조인 (fetchjoin)   SQL 조인 종류는 아니고 JPA에서 제공하는 기능이다. JPQL에서 성능 최적화를 위해 제공하는 기능. 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능 join fetch 명령어 사용 페치 조인 :: = [LEFT [OUTER] | INNER ] JOIN FETCH 조인 경로  엔티티 페치 조인
  회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에)
//JPQL select m from Member m join fetch m.team //SQL select m.* t.* from Member m inner join Team t on m.team_id = t.id;     도식화
팀이 있는 회원을 조회하고 싶을 때 fetch join을 사용하면 내부적으로 inner join을 사용한다.
팀이 없는 회원은 누락된다.
  페치 조인 사용 코드
  기존 연관관계 조회 로직의 문제
String jpql = &#34;select m from Member m&#34;; List&lt;Member&gt; members = em.createQuery(jpql, Member.class) .getResultList(); for (Member member : members) { System.out.println(&#34;username = &#34; + member.getUsername() + &#34;, &#34; + &#34;teamName = &#34; + member.getTeam().name()); //회원1, 팀A(SQL) //회원2, 팀A(1차 캐시) //회원3, 팀B(SQL)  //회원 100명 -&gt; N + 1 } 최초 jpql을 통해 Member를 조회해 올때 Team의 정보는 Proxy객체로 가지고 있다. (실제론 없다는 의미) 그렇기에 실제로 getTeam().getName()을 통해 팀의 정보를 조회하려고 할 때 SQL을 수행한다. 주석 내용대로 한번 가져온 Team의 정보는 1차 캐시에 올라가 있기 때문에 더 조회할 필요는 없지만, 회원을 N명 조회하게 되었을때 최대 N + 1 번 Team 조회 쿼리가 수행 될 수 있다.
    페치 조인을 통한 해결
String jpql = &#34;select m from Member m join fetch m.team&#34;; List&lt;Member&gt; members = em.createQuery(jpql, Member.class) .getResultList(); for (Member member : members) { //페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩X  System.out.println(&#34;username = &#34; + member.getUsername() + &#34;, &#34; + &#34;teamName = &#34; + member.getTeam().name()); } 페치조인은 조회 당시에 실제 엔티티가 담긴다. 그렇기 때문에 지연로딩 없이 바로 사용이 가능하다.
  실무에서 자주 사용된다. 컬렉션 페치 조인
 일대다 관계, 컬렉션 페치 조인  //JPQL select t from Team t join fetch t.members where t.name = &#39;팀A&#39;; //SQL select t.*, m.* from team t, inner join member m on t.]]></description>
</item><item>
    <title>객체지향 쿼리 언어 - 기본 문법</title>
    <link>https://jaeyeonme.github.io/posts/jpa-object-query-language1/</link>
    <pubDate>Thu, 30 Dec 2021 10:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/jpa-object-query-language1/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/jpa.png" referrerpolicy="no-referrer">
            </div>1. 소개  JPA는 다양한 쿼리 방법을 지원
 JPQL JPA Criteria QueryDSL Native SQL JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용  JPQL 소개
 가장 단순한 조회 방법  EntityManager.find() 객체 그래프 탐색 (a.getB().getC())   나이가 18살 이상인 회원을 모두 검색하고 싶다면?  JPQL - 필요성
 JPA를 사용하면 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검 색 조건이 포함된 SQL이 필요  JPQL - 특징
  JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리를 제공
String sql = &#34;select m from Member.class as m where m.username like &#39;%until%&#39;&#34;; 일반 SQL과 비슷하지만 엔티티를 대상으로 한다는 점이 다르다.
 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다. 동적 쿼리 생성이 쉽지 않다.    Criteria - 소개
 문자가 아닌 자바코드로 JPQL을 작성할 수 있음  //Criteria 사용 준비 CriteriaBuilder cb = em.getCriteriaBuilder(); CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class); //루트 클래스 (조회를 시작할 클래스) Root&lt;Member&gt; m = query.from(Member.class); //쿼리 생성 CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(&#34;username&#34;), “kim”)); List&lt;Member&gt; resultList = em.createQuery(cq).getResultList()  JPQL 빌더 역할 JPA 공식 기능  ❌실무에선 거의 사용되지 않는다.
 쿼리를 동적으로 생성할 수는 있지만 구현이 너무 복잡하고 실용성이 없다. 문자가 아닌 자바코드로 JPQL을 작성할 수 있음 JPQL 빌더 역할 JPA 공식 기능 단점 : 너무 복잡하고 실용성이 없다. Criteria 대신에 QueryDSL 사용 권장  QueryDSL 소개
오픈소스 라이브러리
// JPQL // SELECT m from Member m WHERE m.age &gt; 18 JPAFactoryQuery query = new JPAQueryFactory(em); QMember m = QMember.member; List&lt;Member&gt; list = query.selectFrom(m) .where(m.age.gt(18)) .orderBy(m.name.desc()) .fetch();   문자가 아닌 자바코드로 JPQL을 작성할 수 있음
  JPQL 빌더 역할
  컴파일 시점에 문법 오류를 찾을 수 있음
  ... List&lt;Member&gt; list = query.selectFrom(m) .wheree(m.age.gt(18)) //컴파일 시점에서 오류 검출 가능  .orderBy(m.name.desc()) .fetch()  동적쿼리 작성 편리함 단순하고 쉽다. 실무 사용 권장  네이티브 SQL 소개
  JPA가 제공하는 SQL을 직접 사용하는 기능
  JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능
 ex: 오라클 CONNECT BY, 특정 DB만 사용한는 SQL 힌트  String sql =&#34;SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = ‘kim’&#34;; List&lt;Member&gt; resultList = em.createNativeQuery(sql, Member.class) .getResultList();   JDBC 직접 사용, SpringJdbcTemplate 등
  PA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등 함꼐 사용가능
  단, 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요
 ex: JPA를 우회해서 SQL을 실행하기 직전 영속성 컨텍스트를 수동 플러시 해줘야 한다.  Member member = new Member(); member.setUsername(&#34;catsbi&#34;); conn.createQuery(&#34;select * from Member where username = &#39;catsbi&#39;&#34;); //결과 없음 member는 Jdbc가 쿼리를 수행하는시점에서 영속성 컨텍스트에만 있고 db에 아직 저장되지 않았기 때문에 조회결과가 없다 그러므로 쿼리 수행 전 수동으로 플러시를 해줘야 한다.
  2. 기본 문법과 쿼리 API  JPQL 소개
 JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.  EX: 조회 기능을 만들 때 특정 DB에 의존하는 SQL을 따로 안만들어도 된다.   JPQL은 결국 SQL로 변환된다.  객체/DB 모델]]></description>
</item><item>
    <title>값 타입</title>
    <link>https://jaeyeonme.github.io/posts/jpa-value-type/</link>
    <pubDate>Wed, 29 Dec 2021 14:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/jpa-value-type/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/jpa.png" referrerpolicy="no-referrer">
            </div>1. 기본값 타입  엔티티 타입
  @Entity로 정의하는 객체
  데이터가 변해도 식별자로 지속해서 추적 가능
⇒ 엔티티 내부의 모든 값들을 바꿔도 식별자만 유지되면 추적이 가능하다는 의미
  Ex: 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
  값 타입
 int, integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 변경시 추적 불가 Ex: 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체  값 타입 분류
 기본값 타입  자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String   임베디드 타입(enbedded type, 복합 값 타입)  Ex: 우편번호, 좌표같은 복합 값을 Position클래스로 만들어 쓰려고 하는 것을 임베디드 타입   컬렉션 값 타입(collection value type)  Java collection(Array, Map, Set)에 값을 넣을수 있는 것을 컬렉션 값 타입이라 한다.    값 타입 : 기본값 타입
 Ex: String name, int age 생명주기를 엔티티에 의존  회원을 삭제하면 이름, 나이 필드도 함께 삭제   값 타입은 공유하면 안된다.  Side Effect → 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안된다.     참고: 자바의 기본 타입은 절대 공유가 되지 않는다.  int, double 같은 기본 타입(primitive type)은 절대 공유되지 않는다. 기본 타입은 항상 값을 복사함 Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경할 수 없다.    2. 임베디드 타입  개요
 새로운 값 타입을 직접 정의할 수 있다. JPA는 임베디드 타입(embedded type)이라 한다. 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입  임베디드 타입 사용법
 @Embeddable : 값 타입을 정의하는 곳에 표시 @Embedded : 값 타입을 사용하는 곳에 표시 기본 생성자 필수   Example  예제를 통해 알아보는게 이해하기 쉽다.  회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다.
  city, street, zipcode는 주소로 합칠 수 있을 것 같다.
  근무 시작일, 근무 종료일은 근무시간으로 합칠 수 있을 것 같다.
  회원 엔티티의 몇몇 값을 주소, 근무시간으로 합치면 어떻게 될까.
코드를 통해 좀 더 자세히 알아보자.
@Embeddable //값 타입이 정의되는 곳에 @Embeddable 사용 public class Period { private LocalDateTime startDate; private LocalDateTime endDate; public Period() { } } @Embeddable //값 타입이 정의되는 곳에 @Embeddable 사용 public class Address { private String city; private String street; private String zipcode; public Address() { } } @Entity public class Member { @Id @GeneratedValue @Column(name = &#34;MEMBER_ID&#34;) private Long id; @Column(name = &#34;USERNAME&#34;) private String name; /* //임베디드 타입을 사용하지 않으면 주석 내의 기존 형태로 값 타입으로 선언해줘야 한다. //Period private LocalDateTime startDate; private LocalDateTime endDate; //Address private String city; private String street; private String zipcode; */ @Embedded //값 타입이 사용되는 곳에 @Embedded 사용  private Period workPeriod; @Embedded //값 타입이 사용되는 곳에 @Embedded 사용  private Address homeAddress; } 
임베디드 타입의 장점
 재사용  Period나 Address는 다른 객체에서도 사용할 수 있어 재사용성을 높힌다.   높은 응집도 Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있음  private boolean isWork(){ ... }  임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존한다.]]></description>
</item><item>
    <title>프록시와 연관관계 관리</title>
    <link>https://jaeyeonme.github.io/posts/jpa-proxy-and-management/</link>
    <pubDate>Wed, 29 Dec 2021 13:40:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/jpa-proxy-and-management/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/jpa.png" referrerpolicy="no-referrer">
            </div>1. 프록시   프록시란?
 테이블을 조회해서 객체를 가져올 때 연관관계 객체는 안가져 오고 싶으면 어떻게 해야 할까?
  em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
  em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
Member member = em.getReference(Member.class, 1L); System.out.println(&#34;member = &#34; + member.getClass()); // HibernateProxy 객체 getReference() 메서드를 사용하면 진짜 객체가 아닌 하이버네이트 내부 로직으로 프록시 엔티티 객체 반환
내부 구조는 틀은 같지만 내용이 비어있다.
프록시 객체를 반환한다." 프록시 객체를 반환한다.    특징
  실제 클래스를상속받아서 만들어짐
  실제 클래스와 겉 모양이 같다.
  사용하는 입장에서는 진짜 객체인지 구분 필요가 없다. (이론적으로)
  프록시 객체는 실제 객체의 참조(target)를 보관한다.
  프록시 객체를 호출(getName())하면 프록시 객체는 실제 객체의 메소드 호출
  프록시는 처음 사용할 때 한 번만 초기화
  프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해 실제 엔티티에 접근 가능
  프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함( == 비교 실패, 대신 instance of 사용)
m1.getClass() == m2.getClass() //false m1 instanceof Member m2 instanceof Member     영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
Member m1 = em.find(Member.class, member1.getId()); System.out.println(&#34;m1 = &#34;+ m1.getClass());//Member  Member reference = em.getReference(Member.class, member1.getId()); System.out.println(&#34;reference = &#34; reference.getClass()); //Member  m1 == reference //true 이미 Member를 1차 캐시에도 올라와 있는데, 프록시를 반환할 필요가 없다.
    반대로 getReference()로 프록시객체를 가지고 있으면 실제로 find()를 했을때도 프록시 객체를 반환함
  영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
Member refMember = em.getReference(Member.class, member.getId()); System.out.println(&#34;refMember = &#34;+ refMember.getClass());//Proxy  em.detach(refMember); //em.clear  refMember.getUsername(); //org.hibernate.LazyInitializationException   프록시 객체의 초기화
Member member = em.getRefernce(Member.class, &#34;id1&#34;);//(1) member.getName();//(2) 코드 1라인에서 getReference()를 호출하면 프록시객체를 가져온 다음, getName()을 호출하면
JPA가 영속성 컨텍스트에 초기화 요청을 한다.
영속성 컨텍스트에서는 실제 DB를 조회해서 가져온 다음 실제 Entity에 값을 넣어 생성한 다음 프록시 객체는
실제 엔티티를 연결해서 실제 엔티티를 반환한다.
그 이후에는 이미 초기화되어있는 프록시객체 여기에 해당 엔티티를 반환한다.
프록시 확인
 프록시 인스턴스의 초기화 여부 확인 : PersistenceUnitUtil.isLoaded(Object entity) → entityManagerFactory.getPersistenceUnitUtil().isLoaded(object) 프록시 클래스 확인 방법 : entity.getClass().getname() 출력(..javasist.. or HibernateProxy&hellip;) 프록시 강제 초기화 : org.hibernate.Hibernate.initialize(entity); 참고: JPA 표준은 강제 초기화 없음 강제호출 : method.getName();  2. 즉시로딩과 지연로딩  지연 로딩 Member를 조회할 때 Team(연관관계)도 함께 조회해야 할까? : 단순히 member 정보만사용하는 비즈니스 로직
지연 로딩 LAZY을 사용해서 프록시로 조회
fetch = FetchType.LAZY
/*Member*/ @Entity public class Member { ... @ManyToOne(fetch = FetchType.LAZY) //지연로딩 사용  @JoinColumn(name=&#34;TEAM_ID&#34;) private Team team; ... } ... Member m = em.find(Member.class, member1.getId()); // Member 객체 반환 System.out.println(&#34;m = &#34;+ m.getTeam().getClass()); // Team$HibernateProxy객체 반환 m.getTeam().getName() // team을 실제로 사용하는 시점에서 db조회 엔티티 반환 ... 연관관계에 있는 다른 엔티티를 사용하는 빈도수가 낮을 경우 지연로딩을 사용해 불필요한 엔티티 조회를 막을 수 있다.
즉시 로딩 ❓Member와 Team을 같이 쓰는 빈도가 높을 경우에는 어떻게 해야 할까?
즉시 로딩 EAGER를 사용해서 함꼐 조회 fetch = FetchType.EAGER
/*Member*/ @Entity public class Member{ ... @ManyToOne(fetch = FetchType.EAGER) //즉시로딩 사용  @JoinColumn(name=&#34;TEAM_ID&#34;) private Team team; ... } ... Member m = em.]]></description>
</item><item>
    <title>고급 매핑</title>
    <link>https://jaeyeonme.github.io/posts/jpa-advanced-mapping/</link>
    <pubDate>Wed, 29 Dec 2021 13:20:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://jaeyeonme.github.io/posts/jpa-advanced-mapping/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/images/JPA/jpa.png" referrerpolicy="no-referrer">
            </div>1. 상속관계 매핑   관계형 데이터베이스는 상속 관계X 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑  Album, Movie, Book은 모두 id, name, price를 가지고 있다(공통 변수)
슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법 1. 조인전략  Item, Album에 PK,FK가 같아 각각의 테이블에 insert가 수행하고 Item내에 타입을 구분하는 컬럼을 만들어서 구해온다. 장점  정규화도 되어있고, 제약조건을 부모에 걸어 맞출 수 있다.  ex: Order 테이블에서 특정 아이템(영화)의 가격을 볼 때 ITEM 테이블만 봐도 된다.   저장공간 효율화   단점  조회시 조인이 많을 경우 성능 저하 조회 쿼리가 복잡함 데이터 저장시 INSERT SQL 2번 호출(큰 문제는 아님)   조인이 많아도 조건이 잘 걸려있을 경우 성능 하락이 크지 않고 저장공간이 효율적으로 되기에 오히려 더 좋을 수 있다는 점을 고려해야 한다.  2. 단일 테이블 전략 (default)  논리모델을 한 테이블로 합쳐버리는 방법 한 테이블에 다 넣어 놓고 어떤 테이블인지 구분하는 컬럼(ex:DTYPE)을 통해 구분한다. 테이블은 ITEM 테이블 하나만 관리된다. 성능에서 우위를 가질 수 있다. (select or insert가 한번에 수행으로 된다.) @DiscriminatorColumn 이 필수로 들어간다(기입하지 않아도 자동으로 들어감) 장점  조인이 필요 없기에 일반적으로 조회 성능이 빠름 조회 쿼리가 단순함   단점  자식 엔티티가 매핑한 컬럼은 모두 nullable 해야 한다. 단일 테이블에 모든 것을 저장하기에 테이블이 커질 수 있고 상황에 따라서 조회성능이 더 느려질 수 있다. (임계점을 넘을 저도의 상황은 거의 오지 않는다.)    3. 구현 클래스마다 테이블 전략  각각의 테이블마다 별개로 만들어서 따로 관리 ITEM 테이블을 생성하지 않고 ALBUM, MOVIE, BOOK 테이블에서 각각 id, name, price 필드를 가지고 있다. @DiscriminatorColumn을 사용할 수 없다. (구분할 이유가 없다.) ITEM을 조회하면 ALBUM, MOVIE, BOOK 세개의 테이블을 UNION ALL으로 전부 조회해서 가져온다. (단점) 추천하지 않는 전략 (개발자, DBA 양측에서) 장점  서브 타입을 명확하게 구분해서 처리할 때 효과적 Not Null 제약조건 가능   단점  여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION SQL) 자식 테이블을 통합해서 쿼리하기 힘듬    2. 주요 어노테이션 @Inheritance(strategy = InheritanceType.XXX)
 JOINED : 조인전략 SINGLE_TABLE : 단일 테이블 전략 TABLE_PER_CLASS : 구현 클래스마다 테이블 전략  @DiscriminatorColumn(name = &ldquo;DTYPE&rdquo;)
 default : DTYPE 이라는 Column이 super class의 table에 생기고, DTYPE의 값은 sub class의 이름으로 지정된다. SingleTable 전략에서 없어도 DTYPE이 생성되기도 하는데, 그래도 운영상 써주자. 이 어노테이션은 상위 클래스(Item)에서 명시된다. 데이터베이스의 상위 테이블(Item 테이블)에게 구분자 역할을 DTYPE 칼럼을 넣어준다. 애노테이션의 name 속성으로 컬럼명을 바꿔줄 수 있다 (이름속성으로 쓰자).  @DiscriminatorValue(“XXX”)
 이 어노테이션은 하위 클래스(ALBUM, MOVIE, BOOK)에서 사용된다. 상위 테이블(ITEM 테이블)을 조회할때 DTYPE 칼럼에 사용되는 value를 설정해주는 기능이다. 애노테이션을 사용하지 않을 경우 기본 Default 값인 Entity 이름으로 value값이 채워지게 된다. default: classname  3. @MappedSuperclass   공통 매핑 정보가 필요할 때 사용(id, name)  ex: 모든 테이블에 row 생성일, 수정일을 등록해야하는 경우(createdAt, updatedAt)     상속관계 매핑이 아니다. 엔티티도 아니고, 테이블과 매핑되지도 않는다. 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공 부모타입으로 조회, 검색 불가 직접 생성해서 사용할 일이 없으므로 추상클래스 추천  @Entity클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
@MappedSuperclass public abstract class BaseEntity { private String createdBy; private LocalDateTime createdDate; private String modifiedBy; private LocalDateTime lastModifiedDate; } @Entity public class Member extends BaseEntity { } @Entity public class Team extends BaseEntity { } Member member = new Member(); member.]]></description>
</item></channel>
</rss>
